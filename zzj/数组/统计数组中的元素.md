### [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

示例 1：

输入：nums = [1,2,2,4]
输出：[2,3]
示例 2：

输入：nums = [1,1]
输出：[1,2]


提示：

2 <= nums.length <= 104
1 <= nums[i] <= 104

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        nums.sort()
        l = len(nums)
        map = [0 for i in range(l+1)]
        cnt = 0
        repeat = 0
        for i in range(l):
            num = nums[i]
            cnt = cnt + i + 1 - num
            if map[num] == 0:
                map[num] = num
            else:
                repeat = num
        return [repeat,cnt + repeat]
```

思路：

用一个长度为nums.length+1的哈希表依次存储数，发生碰撞的就是重复的数

先升序排序，遍历过程中令cnt = cnt + i + 1 - num，如果是正确的数cnt的增量就是0，最终cnt的值为 丢失的数-重复的数

题解 异或运算：

1.

xor = x 异或 y

则 lowbit = xor & (-xor)表示x和y的最低不同位

2.

依据这一不同位可以把数分为两组

#### [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

 

示例 1：

输入：nums = [1,2,2,3,1]
输出：2
解释：
输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。
连续子数组里面拥有相同度的有如下所示：
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。
示例 2：

输入：nums = [1,2,2,3,1,4,2]
输出：6
解释：
数组的度是 3 ，因为元素 2 重复出现 3 次。
所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。


提示：

nums.length 在 1 到 50,000 范围内。
nums[i] 是一个在 0 到 49,999 范围内的整数。

```python
from collections import deque
class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        l = len(nums)
        NUM_MAX = 49999
        fre = [0 for i in range(NUM_MAX+1)]
        for num in nums:
            fre[num]= fre[num] + 1
        max_fre = 0
        for f in fre:
            if f > max_fre:
                max_fre = f

        maxfre = []
        for i in range(NUM_MAX+1):
            if fre[i] == max_fre:
                maxfre.append(i)
        maxset = set(maxfre)
        print(maxset)
        
        min_l = 50001
        for num in maxset:
            sub_que = deque([])
            for i in range(l):
                if num == nums[i]:
                    sub_que.append(i)
                sub_l = len(sub_que)
                if sub_l == max_fre:
                    if sub_que[max_fre-1] - sub_que[0] + 1  < min_l:
                        min_l = sub_que[max_fre-1] - sub_que[0] + 1
                    sub_que.popleft()

        return min_l  
```

思路：

第一次遍历：找出输入数组的度是多少

第二次遍历：找出哪些数字的度与数组的度相同

第三+次遍历：最短子数组一定以对应数字作为开头和结尾，用一个队列来记录该数字的下标，并在队列长度等于数组度的时候，将首位下标的差+1作为子数组长度，更新最短长度并出队一个下标
