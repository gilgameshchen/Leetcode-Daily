## [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

### 思路

直接记录出现的次数，然后按顺序遍历找次数为1的即可。

```java
class Solution {
    public int firstUniqChar(String s) {
        int[] map = new int[26];
        for (int i = 0; i < s.length(); i++) map[s.charAt(i) - 'a']++;
        for (int i = 0; i < s.length(); i++) {
            if (map[s.charAt(i) - 'a'] == 1) return i;
        }
        return -1;
    }
}
```

## [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

### 思路

时空都为On的很容易想到，这里有两种On，O1的解法

- 将string的ascii码求出来，相减即可得到多余的。

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int sumS = 0, sumT = 0;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            sumS += s.charAt(i);
            sumT += t.charAt(i);
        } 
        sumT += t.charAt(n);
        return (char)(sumT - sumS);
    }
}
```

- 用异或，将偶数个的都消除掉

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int n = s.length();
        int res = (int)t.charAt(n);
        for (int i = 0; i < n; i++) {
            res ^= s.charAt(i);
            res ^= t.charAt(i);
        }
        return (char)res;
    }
}
```

## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

### 思路

直接统计字符就行了。。

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] map = new int[26];
        for (int i = 0; i < magazine.length(); i++) {
            map[magazine.charAt(i) - 'a']++;
        } 

        for (int i = 0; i < ransomNote.length(); i++) {
            if (--map[ransomNote.charAt(i) - 'a'] < 0) return false; 
        }
        return true;
    }
}
```

## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

### 思路

统计。。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        int[] map = new int[26];
        int n = s.length();
        for (int i = 0; i < n; i++) {
            map[s.charAt(i) - 'a']++;
        }

        for (int i = 0; i < n; i++) {
            if (--map[t.charAt(i) - 'a'] < 0) return false;
        }
        return true;
    }
}
```

如果是unicode字符，那就用哈希表。

