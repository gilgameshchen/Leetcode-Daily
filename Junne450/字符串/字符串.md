# 字符串



## 字符：520

### 520.[检测大写字母](https://leetcode-cn.com/problems/detect-capital/)

```java
class Solution {
    public boolean detectCapitalUse(String word) {
        char[] str = word.toCharArray();
        int n = str.length;
        int count = 0;
        if(isCapital(str[n-1])){
            for(int i=n-2;i>=0;i--){
                if(!isCapital(str[i])){
                    return false;
                }
            }
            return true;
        }else{
            for(int i=n-2;i>=1;i--){
                if(isCapital(str[i])){
                    return false;
                }
            }
            return true;
        }        
    }
    private boolean isCapital(char a){
        if(a>='A'&&a<='Z'){
            return true;
        }else{
            return false;
        }
    }
}
```

从后往前检索，若最后一个字母为大写，则前面字母需全为大写；若最后一个字母为小写，则除了第一个字母外所有字母需全为小写。



## 回文串的定义：125

###125.[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

```java
class Solution {
    public boolean isPalindrome(String s) {
        int i = 0;
        int n = s.length();
        int j = n-1;
        String str = s.toLowerCase();
        while(i<=j){
            while(!ischar(str.charAt(i))&&i<j){
                i++;            
            }
            while(!ischar(str.charAt(j))&&i<j){
                j--;
            }
            if(str.charAt(i)==str.charAt(j)){
                i++;
                j--;
            }else{
                return false;
            }
        }
        return true;
    }
    private boolean ischar(char a){
        if((a>='0'&&a<='9')||(a>='a'&&a<='z')){
            return true;
        }else{
            return false;
        }
    }
}
```

转化为小写，ischar()方法判断是否为数字和字符，双指针分别从头尾开始，碰到不符合条件的就++/--，直到指针相遇。

### 14.[最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int len = strs.length;
        int minlen = 200;
        int flag = 0;
        String res = "";
        for(int i = 0;i<len;i++){
            minlen = Math.min(minlen,strs[i].length());
        }
        for(int i = 0;i<minlen&&flag==0;i++){
            char temp = strs[0].charAt(i);
            for(int j = 1;j<len;j++){
                if(strs[j].charAt(i)!= temp){
                    flag = 1;
                    break;
                }
            }
            if(flag==0){
                res += temp;
            }                
        }
            return res;
    }
}
```

一个一个比较即可





## 单词：434、58

### 434.[字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

```java
class Solution {
    public int countSegments(String s) {
        int count = 0;
        int len = s.length();
        for(int i=0;i<len-1;i++){
            if(!isSpace(s.charAt(i))&&isSpace(s.charAt(i+1))){
                count++;
            }
        }
        if(len>0){
            if(!isSpace(s.charAt(len-1))){
            count++;
        }
        }      
        return count;
    }
    private boolean isSpace(char a){
        return a==' ';
    }
}
```

当碰到单词结尾count++，单独统计最后一个单词，注意越界问题即可。



### 58.[最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int count = 0;
        int len = s.length();
        int i = 0;
        for(i = len-1;i>=0;i--){
            if(isArt(s.charAt(i))){
                count++;
                for(int j=i-1;j>=0;j--){
                    if(isArt(s.charAt(j))){
                        count++;
                    }else{
                        break;
                    }
                }
                break;
            }
        }
        return count;
    }
    private boolean isArt(char a){
        return (a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z');
    }
}
```

从后向前统计，遇到第一个字母标记同时count++，从这个位置继续遍历，碰到字母count++，碰到空格直接break，最后count即是结果。



## 字符串的反转：344、541、557、151

### 344.[反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```java
class Solution {
    public void reverseString(char[] s) {
        int len = s.length;
        int i = 0;
        int j = len-1;
        char temp;
        while(i<j){
            temp = s[i];
            s[i] = s[j];
            s[j] = temp;
            i++;
            j--;
        }
    }
}
```

没啥好说，直接换。



### 541.[反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

```java
class Solution {
    public String reverseStr(String s, int k) {
        int n = s.length();
        char[] arr = s.toCharArray();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(arr, i, Math.min(i + k, n) - 1);
        }
        return new String(arr);
    }
    private void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}
```

直接换



### 557.[反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

```java
class Solution {
    public String reverseWords(String s) {
        int n = s.length();
        char[] arr = s.toCharArray();
        int i=0;
        int j=0;
        while(j<n){
            if(arr[j]==' '){
                reverse(arr,i,j-1);
                j++;
                i = j;
            }else{
                j++;
            }
        }
        reverse(arr,i,n-1);
        return new String(arr);
    }
    private void reverse(char[] str,int left,int right){
        char temp;
        while(left<right){
            temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }
}
```

跟上题差不多。



### 151.[翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        String[] str = s.split("\\s+");
        reverse(str,0,str.length-1);
        String res = String.join(" ",str);
        return res;
    }
    private void reverse(String[] str,int left,int right){
        String temp;
        while(left<right){
            temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }

}
```

split后reverse再join。

![image-20220117224441866](C:\Users\朱源\AppData\Roaming\Typora\typora-user-images\image-20220117224441866.png)





## 字符的统计：387、389、383、242、49、451、423、657、551、696、467、535



### 387.[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

```java
class Solution {
    public int firstUniqChar(String s) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        int n = s.length();
        int idx = n;
        for(int i=0;i<n;i++){
            if(map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),n);
            }else{
                map.put(s.charAt(i),i);
            }
        }
        for(Character i:map.keySet()){
            idx = Math.min(map.get(i),idx);
        }
        idx = (idx==n?-1:idx);
        return idx;
    }
}
```

用hashmap储存字符出现的下标，若该字符第二次出现，则将其value改为n，最后遍历hashmap，最小的value即为答案。



### 389.[找不同](https://leetcode-cn.com/problems/find-the-difference/)

```java
class Solution {
    public char findTheDifference(String s, String t) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        int n = s.length();
        for(int i=0;i<n;i++){
            char a = s.charAt(i);
            if(!map.containsKey(a)){
                map.put(a,1);
            }else{
                int temp1 = map.get(a);
                map.put(a,temp1+1);
            }
            
        }
        for(int i=0;i<n+1;i++){
            char b = t.charAt(i);
            if(!map.containsKey(b)){
                return t.charAt(i);
            }else{
                int temp2 = map.get(b);
                if(temp2==1){
                    map.remove(b);
                }else{
                    map.put(b,temp2-1);
                }
            }
        }
        for(Character c : map.keySet()){
            return c;
        }
        return 0;
    }
}
```

遍历s用hashmap储存频次，遍历t将频次减掉，最后剩下的就是多出来的。



### 383.[赎金信](https://leetcode-cn.com/problems/ransom-note/)

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int m = magazine.length();
        int n = ransomNote.length();
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        for(int i=0;i<m;i++){
            char a = magazine.charAt(i);
            if(!map.containsKey(a)){
                map.put(a,1);
            }else{
                int temp = map.get(a);
                map.put(a,temp+1);
            }
        }
        for(int j=0;j<n;j++){
            char b = ransomNote.charAt(j);
            if(!map.containsKey(b)){
                return false;
            }else if(map.get(b)==1){
                map.remove(b);
            }else{
                int temp2 = map.get(b);
                map.put(b,temp2-1);
            }
        }
        return true;
    }
}
```

思路同上题，但参考题解直接用new int[26]来统计，好像比hashmap好一些。



### 242.[有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int m = s.length();
        if(m!=t.length()){
            return false;
        }
        int[] compare = new int[26];
        for(int i=0;i<m;i++){
            compare[s.charAt(i)-'a']++;
            compare[t.charAt(i)-'a']--;
        }
        for(int i=0;i<26;i++){
            if(compare[i]!=0){
                return false;
            }
        }
        return true;
    }
}
```

用new int[26]统计，上题的参考思路。



### 49.[字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String,ArrayList<String>> map=new HashMap<>();
        for(String s:strs){
            char[] ch=s.toCharArray();
            Arrays.sort(ch);
            String key=String.valueOf(ch);
            if(!map.containsKey(key))    map.put(key,new ArrayList<>());
            map.get(key).add(s);
        }
        return new ArrayList(map.values());
    }
}
```



### 451.[根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

```java
class Solution {
    public String frequencySort(String s) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        int len = s.length();
        int max = 0;
        char tempc = 'a';
        char[] res = new char[len];
        for(int i=0;i<len;i++){
            char a = s.charAt(i);
            if(map.containsKey(a)){
                int temp = map.get(a);
                map.put(a,temp+1);
            }else{
                map.put(a,1);
            }
        }
        int j=0;
        while(!map.isEmpty()){
            for(Character b :map.keySet()){
                int num = map.get(b);
                if(num>max){
                    max = num;
                    tempc = b;
                }
            }
            for(int k=0;k<max;k++){
                res[j+k] = tempc;
            }
            j+=max;
            map.remove(tempc);
            max = 0;
        }
        return String.valueOf(res);
    }
}
```

用hashmap记录出现次数，然后遍历hashmap即可。



### 423.[从英文中重建数字](https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/)

+ zero---z
+ one
+ two---w
+ three
+ four---u
+ five
+ six---x
+ seven
+ eight---g
+ nine

```
class Solution {
    public String originalDigits(String s) {
        Map<Character, Integer> c = new HashMap<Character, Integer>();
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            c.put(ch, c.getOrDefault(ch, 0) + 1);
        }

        int[] cnt = new int[10];
        cnt[0] = c.getOrDefault('z', 0);
        cnt[2] = c.getOrDefault('w', 0);
        cnt[4] = c.getOrDefault('u', 0);
        cnt[6] = c.getOrDefault('x', 0);
        cnt[8] = c.getOrDefault('g', 0);

        cnt[3] = c.getOrDefault('h', 0) - cnt[8];
        cnt[5] = c.getOrDefault('f', 0) - cnt[4];
        cnt[7] = c.getOrDefault('s', 0) - cnt[6];

        cnt[1] = c.getOrDefault('o', 0) - cnt[0] - cnt[2] - cnt[4];

        cnt[9] = c.getOrDefault('i', 0) - cnt[5] - cnt[6] - cnt[8];

        StringBuffer ans = new StringBuffer();
        for (int i = 0; i < 10; ++i) {
            for (int j = 0; j < cnt[i]; ++j) {
                ans.append((char) (i + '0'));
            }
        }
        return ans.toString();
    }
}
```

绷，唯一的意义是

```java
	if(map.containsKey(a)){
		int temp = map.get(a);
		map.put(a,temp+1);
	}else{
		map.put(a,1);
	}
```

可以替换成

```java
	map.put(a, c.getOrDefault(a, 0) + 1);
```

思路：z、w、u、x、g只在0，2，4，6，8中出现，故知道了0，2，4，6，8的个数

h 只在 3, 8中出现。由于我们已经知道了 8 出现的次数，因此可以计算出 3 出现的次数。

f 只在 4, 5 中出现。由于我们已经知道了 4 出现的次数，因此可以计算出 5 出现的次数。

s 只在 6, 7中出现。由于我们已经知道了 6 出现的次数，因此可以计算出 7 出现的次数。

o 只在 0, 1, 2, 4 中出现，由于我们已经知道了 0, 2, 4 出现的次数，因此可以计算出1出现的次数。

最后算9





### 657.[机器人能否返回原点](https://leetcode-cn.com/problems/robot-return-to-origin/)

```java
class Solution {
    public boolean judgeCircle(String moves) {
        int len = moves.length();
        int lr = 0;
        int ud = 0;
        for(int i=0;i<len;i++){
            char ch = moves.charAt(i);
            switch(ch){
                case 'L': 
                    lr--;
                    break;
                case 'R': 
                    lr++;
                    break;
                case 'U': 
                    ud--;
                    break;
                case 'D': 
                    ud++;
                    break;
            }
        }
        return ud==0&&lr==0;
    }
}
```

弱智题



### 551.[学生出勤记录 I](https://leetcode-cn.com/problems/student-attendance-record-i/)

```java
class Solution {
    public boolean checkRecord(String s) {
        int len = s.length();
        int p = 0;
        for(int i=0;i<len;i++){
            char ch = s.charAt(i);
            if(ch == 'A'){
                p++;
                if(p>1){
                    return false;
                }
            }
            if(i<len-2&&ch == 'L'){
                if(s.charAt(i+1)=='L'&&s.charAt(i+2)=='L'){
                    return false;
                }
            }
        }
        return true;
    }
}
```

1文



### 696.[计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

```java
class Solution {
    public int countBinarySubstrings(String s) {
        int len = s.length();
        char[] arr = s.toCharArray();
        int i = -1;
        int j = 0;
        int sub1 = 0;
        int sub2 = 0;
        int flag = 0;
        int res = 0;
        for(;j<len;j++){
            if(j==len-1){
                sub1 = sub2;
                sub2 = j-i;
                flag++;
                if(flag>1){
                res += Math.min(sub1,sub2);
                }
            }else if(arr[j]!=arr[j+1]){
                sub1 = sub2;
                sub2 = j-i;
                flag++;
                i = j;
                if(flag>1){
                res += Math.min(sub1,sub2);
                }
            }
        }
        return res;
    }
}
```

统计变化的位置，求这些位置的差值，没两个之间较小的那个累加即为答案，注意头尾也要记录。

例如：001111100，变化的位置（左边下标）为-1，1，6，8，差值为2，5，2，

res=Math.min(2,5)+Math.min(5,2)=4
