# 645. 错误的集合

## [LeetCode](https://leetcode-cn.com/problems/set-mismatch/)

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        boolean[] array = new boolean[nums.length];
        int one=0 , two=0;
        for(int i: nums){
            if(array[i-1] == false){
                array[i-1] = true;
            }else{
                one = i;
            }
        }
        for(int i = 0;i<nums.length;i++){
            if(!array[i]){
                two = i + 1;
            }
        }
        int[] answer = {one, two};
        return answer;
    }
}
```

一个bitmap的问题，使用布尔数组降低内存使用

---

# 697. 数组的度

## [LeetCode](https://leetcode-cn.com/problems/degree-of-an-array/)

给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

```java
class Solution {
    public int findShortestSubArray(int[] nums) {
        Map<Integer, int[]> map = new HashMap<Integer, int[]>();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (map.containsKey(nums[i])) {
                map.get(nums[i])[0]++;
                map.get(nums[i])[2] = i;
            } else {
                map.put(nums[i], new int[]{1, i, i});
            }
        }
        int maxNum = 0, minLen = 0;
        for (Map.Entry<Integer, int[]> entry : map.entrySet()) {
            int[] arr = entry.getValue();
            if (maxNum < arr[0]) {
                maxNum = arr[0];
                minLen = arr[2] - arr[1] + 1;
            } else if (maxNum == arr[0]) {
                if (minLen > arr[2] - arr[1] + 1) {
                    minLen = arr[2] - arr[1] + 1;
                }
            }
        }
        return minLen;
    }
}
```

此题构造了一个巧妙的map，value为一个int[ ]，将所有key对应的度和最短连续连续子数组的信息一并进行了记录，避免了在有多个相同度时，需要重复计算比较的问题。